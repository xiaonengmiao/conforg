#+TITLE: A monolithic configuration file in org-mode
#+AUTHOR: Xiaoyu Wei
#+BABEL: :cache yes
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage{inconsolata}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+PROPERTY: header-args :tangle yes

* Getting started
  Config files for emacs, neovim, bash and more,
  organized in a single [[http://orgmode.org][Org mode]] file.
  Inspired by [[https://github.com/larstvei/dot-emacs][larstvei/dot-emacs]].

  To get started, first download the file
  #+BEGIN_SRC sh :tangle no
    wget https://raw.githubusercontent.com/xywei/conforg/master/conf.org
  #+END_SRC

  *Make your backups.*

  Then run the scrip to tangle. You need Emacs and Org-mode, of course.
  #+BEGIN_SRC sh :tangle no
    emacs -Q --batch --eval '(require (quote org))' \
                     --eval '(org-babel-tangle-file "conf.org")'
  #+END_SRC

  The process generates and installs the dot files for the included programs.
  Note that it will overwrite all the concerned files, so make sure to backup
  your own stuff first.

  To finish the setup for an individual program, see the corresponding
  section for more information.
  (Tip: search for MANUALLY in all caps to find those places).
  
  For the best experience, having a comprehensive set of fonts installed is
  recommended. The following packages are helpful to simplify the process:
  - =aur/all-repository-fonts=
  - =aur/nerd-fonts-complete=

* Meta-configurations
  First of all, set some global options to help setting things up.
  The meta-configurations are set via noweb references.
  
** Conforg directory:
   #+NAME: conforg-dir
   #+BEGIN_SRC sh :results output :exports none :tangle no
     $HOME/.conforg
   #+END_SRC

** Conda directory: 
   Root directory of Anaconda/Miniconda installation
   #+NAME: conda-dir
   #+BEGIN_SRC sh :results output :exports none :tangle no
     $HOME/miniconda3
   #+END_SRC

** Cli-utils directory:
   Directory of my scripts
   #+NAME: cli-utils-dir
   #+BEGIN_SRC sh :results output :exports none :tangle no
     $HOME/cli-utils
   #+END_SRC

* Configurations
** Emacs
*** Header
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
      ;; DO NOT EDIT
      ;; This file is generated by conf.org from xywei/conforg,
      ;; all changes will be overwritten.

      (package-initialize)
    #+END_SRC

*** Native configs
    Configs in here should overrides all the others if there are conflicts,
    which is done using after-init-hook
**** Recent files
     Build a list of recently opened files and access by C-x C-r
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
       (add-hook 'after-init-hook '(lambda ()
	 (progn
	   (recentf-mode 1)
	   (setq recentf-max-menu-items 25)
	   (run-at-time nil (* 5 60) 'recentf-save-list)
	   (global-set-key "\C-x\ \C-r" 'recentf-open-files))))
     #+END_SRC

**** Larger workspace
     Remove scroll bars, menu bars, and toolbars to make more space
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
       (add-hook 'after-init-hook '(lambda ()
       (progn
           (when (fboundp 'menu-bar-mode) (menu-bar-mode -1))
           (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
           (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
         )
       ))
     #+END_SRC

**** Window navigation
     Wind-move (vim-like)
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
       (add-hook 'after-init-hook '(lambda ()
       (progn
           (global-set-key (kbd "C-c h") 'windmove-left)
           (global-set-key (kbd "C-c j") 'windmove-down)
           (global-set-key (kbd "C-c k") 'windmove-up)
           (global-set-key (kbd "C-c l") 'windmove-right)
         )
       ))
     #+END_SRC
**** Smoothen some places
     Make frame to be able to resize to full height
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
       (add-hook 'after-init-hook '(lambda ()
         (progn
           (setq frame-resize-pixelwise t)
         )
       ))
     #+END_SRC

     Disable automatic horizontal scrolling, which causes abrupt jumps.
     Use C-x < and C-x > to do it manually.
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
       (add-hook 'after-init-hook '(lambda ()
         (progn
           (setq auto-hscroll-mode nil)
           )
         ))
     #+END_SRC

**** Split window
     Vertical split by default
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
       (add-hook 'after-init-hook '(lambda ()
         (progn
           (setq split-height-threshold nil)
           (setq split-width-threshold 80)
         )
       ))
     #+END_SRC

*** Spell check
    Spell check needs *aspell* and its dictionaries to be installed
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
      (add-hook 'text-mode-hook 'flyspell-mode)
      (add-hook 'prog-mode-hook 'flyspell-prog-mode)
    #+END_SRC

*** Additional package archives
    Melpa and Marmalade.
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
      (require 'package)
      (add-to-list 'package-archives
           '("melpa" . "http://melpa.milkbox.net/packages/") t)

      (add-to-list 'package-archives
                   '("marmalade" . "http://marmalade-repo.org/packages/") t)
    #+END_SRC

    Org ELPA
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
      (add-to-list 'package-archives
            '("org" . "https://orgmode.org/elpa/") t)
    #+END_SRC

*** Package management
**** Package list
    Define a list of required packages. For ease of use, keep the list
    in alphabetical order.

    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
      (defvar required-packages
        '(
          evil
          fill-column-indicator
          linum-relative
          magit
          org-plus-contrib
          org-ref
          yasnippet
         ) "a list of packages to ensure are installed at launch.")
    #+END_SRC

**** Auto install
    Then install the packaged listed in the required-packages variable

    To reduce overhead, we use a method to check if all packages are installed
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
      (require 'cl)
      (defun packages-installed-p ()
        (loop for p in required-packages
              when (not (package-installed-p p)) do (return nil)
              finally (return t)))
    #+END_SRC

    If not all packages are installed, check one by one and install the missing ones.
    This way Emacs does not refresh its package database everytime it starts.
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
      (unless (packages-installed-p)
        ; check for new packages (package versions)
        (message "%s" "Emacs is now refreshing its package database...")
        (package-refresh-contents)
        (message "%s" " done.")
        ; install the missing packages
        (dolist (p required-packages)
          (when (not (package-installed-p p))
            (package-install p))))
    #+END_SRC

*** Evil-mode
    Replace selection, use Ctrl+u to scroll
    (more natural to vim users)
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
     (setq evil-want-C-u-scroll t)
     (delete-selection-mode t)
    #+END_SRC

    Enable global evil-mode
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
      (require 'evil)
      (evil-mode 1)
    #+END_SRC

    Adding new word to dictionary
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
      (define-key evil-normal-state-map "zg" 'flyspell-correct-word-before-point)
    #+END_SRC

*** FCI (indicate column 80)
    Indicate column 80 for programming and text editing
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
      (add-hook 'prog-mode-hook 'turn-on-fci-mode)
      (add-hook 'text-mode-hook 'turn-on-fci-mode)
    #+END_SRC

    Set the styles
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
      (setq-default fill-column 80)
      (setq fci-rule-width 1)
      (setq fci-rule-color "dark orange")
      (require 'fill-column-indicator)
    #+END_SRC

*** Relative line numbers
    This mode recreates a handy feature from Vim by displaying relative line
    numbers.

    Currently the emacs version in Arch repo is 25. When it is updated to 26,
    use `display-line-number-mode` as linum-mode's backend for smooth performance.
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
      ;; (setq linum-relative-backend 'display-line-numbers-mode)
    #+END_SRC

    Show the real line number of the current line instead of "0"
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
      (setq linum-relative-current-symbol "")
    #+END_SRC

    This mode is so nice that I want it to be always on
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
      (require 'linum-relative)
      (add-hook 'prog-mode-hook 'linum-relative-mode)
      (add-hook 'text-mode-hook 'linum-relative-mode)
    #+END_SRC

    One caveat: it does not play well with folding.
    [[https://github.com/syl20bnr/spacemacs/issues/6536][Read more about this issue]]

*** Org-mode
**** Display
    Fontify code in code blocks
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
      (with-eval-after-load 'org
        (setq org-src-fontify-natively t))
    #+END_SRC

    Make latex fragments larger, default is roughly 100 font size
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
      (with-eval-after-load 'org
        (plist-put org-format-latex-options :scale 1.6))
    #+END_SRC

**** Behaviors
    Auto new-line
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
      (add-hook 'org-mode-hook 'turn-on-auto-fill)
    #+END_SRC

    Toggle latex preview with fewer key strokes
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
       (add-hook 'org-mode-hook
         (lambda () (local-set-key (kbd "C-c p") 'org-toggle-latex-fragment)))
    #+END_SRC

**** References
     For org-ref. Load the module and set keybindings or inserting citations and
     cross-references.
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
       (with-eval-after-load 'org
         (require 'org-ref))
       (add-hook 'org-mode-hook
         (lambda ()
           (setq org-latex-prefer-user-labels t)
           (local-set-key (kbd "C-c c") 'org-ref-helm-insert-cite-link)
           (local-set-key (kbd "C-c r") 'org-ref-helm-insert-ref-link)
           ))
     #+END_SRC

**** Writing layout
     A layout for writing long articles (inspired by Scrivener).

     First define a function that helps with the layout. It enlarges current
     window to twice the size of the other (assuming there are only two of them).
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
       (with-eval-after-load 'org
         (defun halve-other-window-width ()
           "Expand current window to use half of the other window's width."
           (interactive)
           (enlarge-window-horizontally (/ (window-width (next-window)) 2))))
     #+END_SRC

     This function opens content under the current header and moves over the
     cursor.
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
       (with-eval-after-load 'org
         (defun org-tree-open-in-new-window ()
           (interactive)
           (delete-other-windows)
           (org-tree-to-indirect-buffer)
           (other-window 1)
           (halve-other-window-width)
           (rename-buffer (org-get-heading) t)))
     #+END_SRC

     Bind this to Ctrl+Shift+Enter
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
       (with-eval-after-load 'org
         (define-key org-mode-map
           [C-S-return] 'org-tree-open-in-new-window))
     #+END_SRC

     This function opens content under the current header but does not move the
     cursor.
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
       (with-eval-after-load 'org
         (defun org-tree-open-in-new-window-cursor-stays ()
           (interactive)
           (delete-other-windows)
           (org-tree-to-indirect-buffer)
           (other-window 1)
           (halve-other-window-width)
           (rename-buffer (org-get-heading) t)
           (other-window 1)))
     #+END_SRC

     Bind this to Shift+Enter
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
       (with-eval-after-load 'org
         (define-key org-mode-map
           [S-return] 'org-tree-open-in-new-window-cursor-stays))
     #+END_SRC

**** Export
     Allow ignoring heading while export the content of subtrees
     #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
       (with-eval-after-load 'org
         (require 'ox-extra)
         (ox-extras-activate '(ignore-headlines)))
     #+END_SRC

*** YaSnippet
**** Configs
    Enable global yas-global-mode
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
      (require 'yasnippet)
      (yas-global-mode 1)
    #+END_SRC

    Let the snippets be saved in my own place
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
      (yas-load-directory "~/.emacs.d/snippets")
    #+END_SRC

    Don't expand snippets in terminal mode
    #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
      (add-hook 'term-mode-hook (lambda()
          (setq yas-dont-activate t)))
    #+END_SRC

**** Snippets
     Here are some snippets that I would like to have on all my machines
     
** Firefox

   The configs for Firefox allows easily resetting it my `rm -rf ~/.mozilla` and
   then get back to a reasonable starting point quickly. Alternatively the same
   thing can be achieved more easily by web syncing. But I prefer having fine
   grained controls.

*** User.js
    See [[http://kb.mozillazine.org/User.js_file][the doc]] for more information.
    This section generates a `user.js` files under the user's home directory.
    The file needs to be *MANUALLY* moved into the
    actual profile directory being used to take effect.
    
    Make accidental Ctrl+Q less annoying
    #+BEGIN_SRC js :tangle "~/.mozilla/user.js"
      // Warn on exiting
      user_pref("browser.warnOnQuit", true);
      user_pref("browser.showQuitWarning", true);
    #+END_SRC

    Make Ctrl+W to be able to close the window
    #+BEGIN_SRC js :tangle "~/.mozilla/user.js"
      // Ctrl+W closes the window if there is only one tab
      user_pref("browser.tabs.closeWindowWithLastTab", true);
    #+END_SRC

*** Extensions

    Open Firefox, then run
    #+BEGIN_SRC sh :tangle no
      sh ~/.mozilla/install_firefox_extensions.sh
    #+END_SRC
    It opens the pages for you to install/update the
    extensions. However, some extensions need additional setup work that
    is not fully automated yet. See the instructions below for details.

**** AdblockPlus
     Block some ads and trackers that come along.
     Install the latest extension 
     #+BEGIN_SRC bash :tangle "~/.mozilla/install_firefox_extensions.sh"
       firefox https://update.adblockplus.org/latest/adblockplusfirefox.xpi
     #+END_SRC
     
**** HTTPS Everythere
     Good stuff made by EFF! Install the latest extension
     #+BEGIN_SRC bash :tangle "~/.mozilla/install_firefox_extensions.sh"
       firefox https://www.eff.org/files/https-everywhere-latest.xpi
     #+END_SRC
     
**** Privacy Badger
     Good stuff made by EFF! Install the latest extension
     #+BEGIN_SRC bash :tangle "~/.mozilla/install_firefox_extensions.sh"
       firefox https://www.eff.org/files/privacy-badger-latest.xpi
     #+END_SRC
     
**** Spell Checker
     The spell checker for English
     #+BEGIN_SRC bash :tangle "~/.mozilla/install_firefox_extensions.sh"
       firefox https://addons.mozilla.org/en-US/firefox/addon/united-states-english-spellche/
     #+END_SRC

**** Tab Numbering
     This extension adds numbers to each tab title, making it convenient to
     switch tabs using Alt+Number.
     Install the extension 
     #+BEGIN_SRC bash :tangle "~/.mozilla/install_firefox_extensions.sh"
       firefox https://addons.mozilla.org/en-US/firefox/addon/tab-numbering/
     #+END_SRC

**** Vimium-FF
     Install the extension
     #+BEGIN_SRC bash :tangle "~/.mozilla/install_firefox_extensions.sh"
       firefox https://addons.mozilla.org/en-US/firefox/addon/vimium-ff/
     #+END_SRC
     
     Some custom keymappings that has to be added *MANUALLY*
     #+BEGIN_SRC bash :tangle no
       map d removeTab
       map u restoreTab
       map J nextTab
       map K previousTab
     #+END_SRC
     
     Disable on certain URLs, added *MANUALLY*
     #+BEGIN_SRC bash :tangle no
       *.ipynb
     #+END_SRC

** i3
*** Basic Settings
   Some added customization based on generated i3 config file.
   At the moment it has to be added MANUALLY to =~/.config/i3/config=
   Note that =i3-renameworkspaces= needs some perl modules
   - =AnyEvent::I3= available as =any/perl-anyevent-i3=
   - =Linux::Itodify2= available from AUR as =aur/perl-linux-inotify2=
   #+BEGIN_SRC conf :noweb yes :tangle ~/.config/i3/generated_by_conforg
     # Dynamic workspace naming
     exec_always --no-startup-id exec <<conforg-dir>>/contrib/i3-renameworkspaces/i3-renameworkspaces.pl

     # Lock screen
     bindsym $mod+Shift+d exec slock
   #+END_SRC
   
   Multimedia key support
   #+BEGIN_SRC conf :tangle ~/.config/i3/generated_by_conforg
     # Volume control from my daskeyboard
     bindsym XF86AudioRaiseVolume exec --no-startup-id pactl set-sink-volume @DEFAULT_SINK@ +5% #increase sound volume
     bindsym XF86AudioLowerVolume exec --no-startup-id pactl set-sink-volume @DEFAULT_SINK@ -5% #decrease sound volume
     bindsym XF86AudioMute exec --no-startup-id pactl set-sink-mute @DEFAULT_SINK@ toggle # mute sound

     # Brightness control via xbacklight
     # using two seldomly used keys
     bindsym Pause exec --no-startup-id xbacklight -inc 5
     bindsym Print exec --no-startup-id xbacklight -dec 5
   #+END_SRC
   
*** i3 Status
    
    Generate i3bar layout. Add the conf file to i3status invocation by modifying
    the i3 configuration file
    #+BEGIN_SRC conf :tangle ~/.config/i3/generated_by_conforg
      bar {
	  status_command i3status -c ~/.config/i3/i3status.conf
      }
    #+END_SRC
    
    Then the =i3status.conf= is handled for you
    #+BEGIN_SRC conf :tangle ~/.config/i3/i3status.conf
      general {
	colors = true
	interval = 1
      }

      order += "ethernet _first_"
      order += "wireless _first_"
      order += "load"
      order += "cpu_usage"
      order += "cpu_temperature 0"
      order += "disk /"
      order += "battery 0"
      order += "volume master"
      order += "time"

      battery 0 {
	last_full_capacity = true
	# format = "%status %percentage"
	format = "%percentage"
	format_down = ""
	status_chr = "⚡ CHR"
	status_bat = "🔋 BAT"
	status_unk = "? UNK"
	status_full = "☻ FULL"
	path = "/sys/class/power_supply/CMB0/uevent"
	low_threshold = 10
      }

      ethernet _first_ {
      # if you use %speed, i3status requires root privileges
	format_up = " Ethernet  %speed  %ip"
	format_down = ""
      }

      wireless _first_ {
	format_up = " Wifi  %quality  %essid  %bitrate  %ip"
	# format_down = "wlan0 "
	format_down = ""
      }

      time {
	format = " %a, %d %b %H:%M:%S"
      }

      load {
	format = " %1min"
      }

      cpu_usage {
	format = " %usage"
      }

      cpu_temperature 0 {
	format = " %degrees°C"
	max_threshold = "65"
      }

      disk "/" {
	format = " %avail"
      }

      volume master {
	format = " %volume"
	format_muted = " %volume"
	device = "default"
	mixer = "Master"
	mixer_idx = 0
      }
    #+END_SRC
   
** Neovim
*** Detect Platform
    Assign the results to `s:uname`.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      if has('unix')
	let s:uname = system("uname")
	" Assume that llvm is installed via homebrew on MacOS
	" brew install llvm --with-clang
	if s:uname == "Darwin\n"
	  let g:chromatica#libclang_path='/usr/local/opt/llvm/lib/libclang.dylib'
	endif
	" Assme that this a an Arch linux, using clang from pacman
	if s:uname == "Linux\n"
	  " libclang in miniconda takes priority
	  if filereadable("~/miniconda3/lib/libclang.so")
	    let g:chromatica#libclang_path='~/miniconda3/lib/libclang.so'
	  elseif filereadable("/usr/lib/libclang.so")
	    let g:chromatica#libclang_path='/usr/lib/libclang.so'
	  endif
	endif
      endif
    #+END_SRC

*** Vim-Plug General Plugin List
    Install plugins under `.vim/plugged`.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      call plug#begin('~/.vim/plugged')
    #+END_SRC
    
    Vim-airline.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      Plug 'vim-airline/vim-airline'
      Plug 'vim-airline/vim-airline-themes'
    #+END_SRC
    
    VOom: an outliner based on folding marks.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      Plug 'vim-voom/VOoM'
    #+END_SRC
    
    Syntax highlighting for prm files.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      Plug 'xywei/vim-dealii-prm'
    #+END_SRC
    
    Neomake (note: do not use it with other async
    frameworks like ale).
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      Plug 'neomake/neomake'
    #+END_SRC

    Help visually display indent levels
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      Plug 'nathanaelkane/vim-indent-guides'
    #+END_SRC
    
    Display ansi escape sequences in a readable way
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      Plug 'IngoHeimbach/vim-plugin-AnsiEsc'
    #+END_SRC
    
    Tag bar.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      Plug 'majutsushi/tagbar'
    #+END_SRC
    
    CtrlP.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      Plug 'ctrlpvim/ctrlp.vim'
    #+END_SRC
    
    NerdTree with lazy loading.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      Plug 'scrooloose/nerdtree', { 'on':  'NERDTreeToggle' }
    #+END_SRC
    
    Easy align.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      Plug 'junegunn/vim-easy-align'
    #+END_SRC

    Enable stuff like ds, cs and yss
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      Plug 'tpope/vim-surround'
    #+END_SRC

    Auto comment manipulation.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      Plug 'tpope/vim-commentary'
    #+END_SRC
    
    Match pairs of quotes etc.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      Plug 'Raimondi/delimitMate'
    #+END_SRC

*** Plugin Parameters
**** TagBar
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      let g:tagbar_width = 50
      let g:tagbar_type_tex = {
	    \ 'ctagstype' : 'latex',
	    \ 'kinds'     : [
	    \ 's:sections',
	    \ 'g:graphics:1',
	    \ 'l:labels:1',
	    \ 'r:refs:1',
	    \ 'p:pagerefs:1'
	    \ ],
	    \ 'sort'    : 0
	    \ }
    #+END_SRC

**** CtrlP
     Ignore certain file types.
     (Install `ag` from `community/the_silver_searcher`.)
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      let g:ctrlp_cmd = 'CtrlP'
      let g:ctrlp_working_path_mode = 'ra'
      set wildignore+=*/tmp/*,*.so,*.swp,*.zip,*.gz
      let g:ctrlp_user_command = 'ag %s -l --nocolor --hidden -g ""'
    #+END_SRC

**** Vim-Commentary
     Set commentstring for files not supported by default
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      autocmd FileType apache setlocal commentstring=#\ %s
    #+END_SRC

**** delimitMate
    Do not automatically close stuff.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      let delimitMate_autoclose = 0
    #+END_SRC

*** Language-Specific Plugins
*** Key Maps
    Toggle outline using VOom.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      nnoremap <Leader>v :VoomToggle<cr>
      nnoremap <Leader>o :VoomToggle<cr>
    #+END_SRC

    Set how airline looks and tmux integration.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      let g:airline_powerline_fonts = 1
      let g:airline_theme='sol'
      let g:airline#extensions#tabline#enabled = 1
      let g:airline#extensions#tmuxline#enabled = 1
      let g:airline#extensions#tmuxline#snapshot_file = "~/.tmux-statusline-colors.conf"
    #+END_SRC
    
    Toggle tag bar.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      nmap <Leader>t :TagbarToggle<cr>
      nmap tb :TagbarToggle<cr>
    #+END_SRC
    
    Start fuzzy search
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      let g:ctrlp_map = '<c-p>'
    #+END_SRC

    Start interactive EasyAlign.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      xmap ga <Plug>(EasyAlign)
      nmap ga <Plug>(EasyAlign)
      xmap <Leader>a <Plug>(EasyAlign)
      nmap <Leader>a <Plug>(EasyAlign)
    #+END_SRC
    
    Toggle nerd-tree.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      map <C-n> :NERDTreeToggle<CR>
      nmap <Leader>f :NERDTreeToggle<cr>
    #+END_SRC
    
*** Add Plugins to Runtimepath
    Note that some configurations have to
    go after this.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      call plug#end()
    #+END_SRC

*** Auto-completion
    Ways to do auto-completion:
    1. vim's defaualt keybindings, among which the
       awesome ones are:
       - Ctrl+x Ctrl+n  Just this file
       - Ctrl+x Ctrl+f  For filenames (under var path)
       - Ctrl+x Ctrl+]  For tags

       - Ctrl+n         Everything specified by the 'complete' option

    2. vim's omnifunc Ctrl+x Ctrl+o
       (often too verbose)

    3. Deoplete plugin Ctrl+l (clang based)

*** Find Cursor
    Lost track of cursor?
    Press `<Leader> + K`!
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      hi CursorLine cterm=NONE ctermbg=darkred ctermfg=white
      hi CursorColumn cterm=NONE ctermbg=darkred ctermfg=white
      function FindCursor()
	if !exists("s:highlightcursor")
	  let s:highlightcursor=1
	  set cursorline
	  set cursorcolumn
	else
	  unlet s:highlightcursor
	  set nocursorline
	  set nocursorcolumn
	endif
      endfunction
      nnoremap <Leader>K :call FindCursor()<CR>
      nnoremap <Leader>k :call FindCursor()<CR>
    #+END_SRC

*** Kill Trailing Spaces
    Defines two commands to work with
    trailing spaces:

    1. `ShowSpaces`
    2. `TrimSpaces`

    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      function ShowSpaces(...)
	let @/='\v(\s+$)|( +\ze\t)'
	let oldhlsearch=&hlsearch
	if !a:0
	  let &hlsearch=!&hlsearch
	else
	  let &hlsearch=a:1
	end
	return oldhlsearch
      endfunction

      function TrimSpaces() range
	let oldhlsearch=ShowSpaces(1)
	execute a:firstline.",".a:lastline."substitute ///gec"
	let &hlsearch=oldhlsearch
      endfunction

      command -bar -nargs=? ShowSpaces call ShowSpaces(<args>)
      command -bar -nargs=0 -range=% TrimSpaces <line1>,<line2>call TrimSpaces()
    #+END_SRC

*** Line Numbers
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      set relativenumber
      set number
    #+END_SRC

*** Swap Files
    Turn off swap files (often troubsome,
    for example, when in shared folders)
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      set noswapfile
    #+END_SRC

    Auto-reload files changed outside vim
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      set autoread
    #+END_SRC

*** Tag Files
    A command to make tags for the project
    After generating the tags, use
    - Ctrl+] to jump to tag
    - g Ctrl+] to list all matches
    - Ctrl+t to jump back
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      command! MakeTags !ctags -R .
    #+END_SRC

*** Additional Settings
    Enable mouse.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      set mouse=a
    #+END_SRC
    
    File type system.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      filetype plugin indent on
    #+END_SRC

    Use system clipboard
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      if (executable('pbcopy') || executable('xclip') || executable('xsel')) && has('clipboard')
	set clipboard=unnamed
      endif
    #+END_SRC

    Set python interpreter on MacOS (ignore virtualenv and conda)
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      if s:uname == "Darwin\n"
	let g:python_host_prog='/usr/local/bin/python2'
	let g:python3_host_prog='/usr/local/bin/python3'
      endif
    #+END_SRC

    Set python interpreter on Linux (ignore virtualenv and conda)
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      if s:uname == "Linux\n"
	let g:python_host_prog='/usr/bin/python2'
	let g:python3_host_prog='/usr/bin/python3'
      endif
    #+END_SRC

    Display all matchings when we do tab complete
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
    set wildmenu
    #+END_SRC

    Use markers to fold
    also enable space to trigger the fold in normal mode
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      set foldmethod=marker
      nnoremap <space> za
    #+END_SRC

    Make highlighted text more readable.
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      hi Search cterm=None ctermbg=blue ctermfg=white
    #+END_SRC
    
    Smooth scrolling
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      set scrolloff=4
      set nolazyredraw
    #+END_SRC

    Change the cursor shape in the terminal
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      :let $NVIM_TUI_ENABLE_CURSOR_SHAPE=1
    #+END_SRC

    Turn off blink in normal mode
    #+BEGIN_SRC conf :tangle ~/.config/nvim/init.vim
      set gcr=n:blinkon0
    #+END_SRC


** Tmux
*** Basic Settings.
   Note: this config does not unset all default keybindings, for example,
   #+BEGIN_SRC conf :tangle no
     bind-key          d detach-client
     bind-key          0 select-window -t :0
     bind-key          1 select-window -t :1
     bind-key          2 select-window -t :2
     bind-key          3 select-window -t :3
     bind-key          4 select-window -t :4
     bind-key          5 select-window -t :5
     bind-key          6 select-window -t :6
     bind-key          7 select-window -t :7
     bind-key          8 select-window -t :8
     bind-key          9 select-window -t :9
     bind-key          : command-prompt
     bind-key          ? list-keys
     bind-key          i display-message
     bind-key          { swap-pane -U
     bind-key          } swap-pane -D
     bind-key          v copy-mode
   #+END_SRC

   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     # DO NOT EDIT
     # This file is generated by conf.org from xywei/conforg,
     # all changes will be overwritten.
   #+END_SRC
   
   Better colors
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     set -g default-terminal "screen-256color"
   #+END_SRC

   Increase scroll-back history.
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     set -g history-limit 100000
   #+END_SRC

   Use vim key bindings.
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     setw -g mode-keys vi
   #+END_SRC

   Allow using mouse
   Note: this only works for tmux version >= 2.1
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     set -g mouse on
   #+END_SRC

   Copy mouse-selected text to clipboard
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     bind-key -T copy-mode-vi MouseDragEnd1Pane send -X copy-pipe "xclip" \; display-message "Copied to clipboard."
   #+END_SRC

   Decrease command delay (increase vim responsiveness)
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     set -g escape-time 1
   #+END_SRC

   Setup 'v' to begin selection and 'y' to yank as in Vim
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     bind-key -T copy-mode-vi v send -X begin-selection
     bind-key -T copy-mode-vi y send -X copy-pipe "xclip" \; display-message "Copied to clipboard."
   #+END_SRC

   Increase repeat time for repeatable commands
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     set -g repeat-time 1000
   #+END_SRC

   Start window and pane index at 1
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     set -g base-index 1
     set -g pane-base-index 1
   #+END_SRC

   Highlight window when it has new activity
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     setw -g monitor-activity on
     set -g visual-activity on
   #+END_SRC

   Automatic renumber/rename windows
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     set -g renumber-windows on
     set -g automatic-rename on
   #+END_SRC
*** Look and Feel
   Set terminal title
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     set -g set-titles on
     set -g set-titles-string '#h ❐ #S ● #I #W'
   #+END_SRC
 
   Slightly longer pane indicators/status messages display time
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     set -g display-panes-time 800
     set -g display-time 1000
   #+END_SRC

   24 hour clock
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     setw -g clock-mode-style 24
   #+END_SRC

   Rather than constraining window size to the maximum size of any client
   connected to the *session*, constrain window size to the maximum size of any
   client connected to *that window*. Much more reasonable.
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     setw -g aggressive-resize on
   #+END_SRC
   
   Status bar
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     set-option -g status on
     set -g status-position bottom
     set -g status-attr dim
     set -g status-interval 2
     set -g status-justify left
   #+END_SRC
   

   Show host name, session, window, pane in the left
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     set -g status-left-length 50
     set -g status-left ' '
   #+END_SRC

   Date and time on right side
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     set -g status-right-length 60
     set -g status-right '#[fg=colour233,bg=colour241,bold] %d/%m #[fg=colour233,bg=colour245,bold] %H:%M:%S '
   #+END_SRC

   From tmuxline.vim
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     if-shell "test -f ~/.tmux-status.conf" "source ~/.tmux-status.conf"
     if-shell "test -f ~/cli-utils/tmuxline" "source ~/cli-utils/tmuxline"
   #+END_SRC
   
   Bold messages
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     set -g message-attr bold
     setw -g mode-attr bold
   #+END_SRC

*** Key Bindings
   Tmux prefix: `C-j` for usual sessions, `C-k` for nested sessions.
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     unbind C-b
     set -g prefix 'C-j'
     bind-key -n 'C-k' send-prefix
   #+END_SRC

   Quickly reload .tmux.conf
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     unbind r
     bind r source-file ~/.tmux.conf \; display "Reloaded!"
   #+END_SRC

   New window
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     bind t new-window
   #+END_SRC

   Window splitting: `|` vertical, `-` horizontal
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     unbind %
     bind | split-window -h -c "#{pane_current_path}"
     unbind '"'
     bind - split-window -v -c "#{pane_current_path}"
   #+END_SRC

   Enhanced C-l that now clears both screen and history
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     bind ` send-keys C-l \; run 'tmux clear-history'
   #+END_SRC

   For vim-tmux-navigator.
   Smart pane switching with awareness of Vim splits.
   See: https://github.com/christoomey/vim-tmux-navigator
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     is_vim="ps -o state= -o comm= -t '#{pane_tty}' \
         | grep -iqE '^[^TXZ ]+ +(\\S+\\/)?g?(view|n?vim?x?)(diff)?$'"
   #+END_SRC

   Caveat: only works in normal mode
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     bind h if-shell "$is_vim" "send-keys :TmuxNavigateLeft Enter"  "select-pane -L"
     bind j if-shell "$is_vim" "send-keys :TmuxNavigateDown Enter"  "select-pane -D"
     bind k if-shell "$is_vim" "send-keys :TmuxNavigateUp Enter"  "select-pane -U"
     bind l if-shell "$is_vim" "send-keys :TmuxNavigateRight Enter"  "select-pane -R"
     bind \ if-shell "$is_vim" "send-keys :TmuxNavigatePrevious Enter" "select-pane -l"
   #+END_SRC

   Resize panes
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     bind H resize-pane -L 5
     bind J resize-pane -D 5
     bind K resize-pane -U 5
     bind L resize-pane -R 5
   #+END_SRC

   Repeat last shell command on the right pane (if
   it happens to be a shell)
   binding to "m" for "make"
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     bind m select-pane -t 2 \; \
       send-keys q C-c C-m clear C-m \
       tmux Space clear-history C-m \
       Up Up Up C-m \; \
       last-pane
   #+END_SRC

   Enter copy-mode
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     bind-key -n C-q copy-mode
   #+END_SRC

   History navigation
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     bind-key -T copy-mode-vi Home send -X history-top
     bind-key -T copy-mode-vi End send -X history-bottom
     bind-key -T copy-mode-vi -n S-PPage send -X halfpage-up
     bind-key -T copy-mode-vi -n S-NPage send -X halfpage-down
   #+END_SRC

   Swap right pane in window 1 with default pane in window 2,
   binding to "p" for "pane_swap".
   Make sure our current window is listed as 1
   - create a second window if it does not exist
   - select our 1 window again in case we created a new one
   - select our 2nd pane in 1 window
   - join that pane to window 2
   - select the pane above the one we just moved there
   - move that pane to window 1
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     bind p \
     if-shell 'tmux select-window -t :1' '' 'move-window -t :1' \; \
     if-shell 'test $(tmux list-panes | wc -l) -gt 1' '' 'split-window -h' \; \
     if-shell 'tmux select-window -t :2' '' 'new-window' \; \
     select-window -t 1 \; \
     select-pane -t 2 \; \
     join-pane -t 2.1 \; \
     select-pane -U \; \
     join-pane -h -t 1.1 \; \
     last-pane
   #+END_SRC
   
   Clock
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     bind-key          c clock-mode
   #+END_SRC

   Show pane indicators
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     bind-key          p display-panes
   #+END_SRC

*** Tmux Plugin Manager (TPM)
   Hit `prefix + I` to fetch the plugins and source them.
   Hit `prefix + U` to update plugins.

   List of plugins
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     set -g @plugin 'tmux-plugins/tpm'
     set -g @plugin 'tmux-plugins/tmux-resurrect'
     set -g @plugin 'tmux-plugins/tmux-open'
   #+END_SRC

   Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)
   #+BEGIN_SRC conf :tangle ~/.tmux.conf
     run '~/.tmux/plugins/tpm/tpm'
   #+END_SRC
** Ranger
   #+BEGIN_SRC conf :tangle ~/.config/ranger/rc.conf
     # DO NOT EDIT
     # This file is generated by conf.org from xywei/conforg,
     # all changes will be overwritten.
   #+END_SRC
   
   Use the monocolor theme and enable image previews.
   #+BEGIN_SRC conf :tangle ~/.config/ranger/rc.conf
     set colorscheme snow
     set preview_images true
   #+END_SRC
   
   Then there is a plugin that sets glyph for each file included in =contrib/=
   and is set up by running =install.sh=.

** X Resources
*** Header
    #+BEGIN_SRC conf :tangle "~/.Xresources"
      ! DO NOT EDIT
      ! This file is generated by conf.org from xywei/conforg,
      ! all changes will be overwritten.
    #+END_SRC

*** URXVT
    Scrolling control
    #+BEGIN_SRC conf :tangle "~/.Xresources"
    ! do not scroll with output
    URxvt*scrollTtyOutput: false

    ! scroll in relation to buffer (with mouse scroll or Shift+Page Up)
    URxvt*scrollWithBuffer: true

    ! scroll back to the bottom on keypress
    URxvt*scrollTtyKeypress: true

    ! disable the scrollback buffer for the secondary screen
    URxvt*secondaryScreen: 1
    URxvt*secondaryScroll: 0

    ! hide scroll bar
    URxvt.scrollBar: false
    #+END_SRC
    
    Fonts installed from:
    - WenQuanYi Zen Hei (Chinese) font from =any/wqy-zenhei=
    - WenQuanYi Micro Hei (Chinese) font from =any/wqy-microhei=
    - Nerd fonts from =aur/nerd-fonts-complete=
    #+BEGIN_SRC conf :tangle "~/.Xresources"
      URxvt.font: xft:Inconsolata Nerd Font Mono:pixelsize=20:minspace=False,xft:WenQuanYi Micro Hei Mono:pixelsize=20,xft:WenQuanYi Zen Hei Mono:pixelsize=20,xft:DejaVu Sans Mono Nerd Font Complete:pixelsize=20:minspace=False
      URxvt*letterSpace: 0
    #+END_SRC
*** High DPI
    i3-status and i3's window decorations respect Xresources.
    #+BEGIN_SRC conf :tangle "~/.Xresources"
      Xft.dpi: 150
      Xft.autohint: 0
      Xft.lcdfilter:  lcddefault
      Xft.hintstyle:  hintfull
      Xft.hinting: 1
      Xft.antialias: 1
      Xft.rgba: rgb
    #+END_SRC

** Xmodmap
   Map Capslock to be Esc
   #+BEGIN_SRC conf :tangle "~/.Xmodmap"
     clear Lock
     keycode 0x42=Escape
   #+END_SRC

** Zsh
*** General Information
   This section contains configurations for zshell. To change the default shell
   for the current user, run
   #+BEGIN_SRC sh :tangle no
     chsh -s /bin/zsh
   #+END_SRC
   
   I am not using any framework for my configurations. If you are new to zsh,
   you will probably be interested in checking out one of them, e.g., oh-my-zsh.
   
   A way to profile the startup time as explained in [[https://kev.inburke.com/kevin/profiling-zsh-startup-time/][this blog post]] is to use
   this snippet at the start of =zshrc=:
   #+NAME: start-profiling
   #+BEGIN_SRC sh :results output :exports none :tangle no
     PROFILE_STARTUP=false
     if [[ "$PROFILE_STARTUP" == true ]]; then
	 PS4=$'%D{%M%S%.} %N:%i> '
	 mkdir -p $HOME/tmp
	 exec 3>&2 2>$HOME/tmp/startlog.$$
	 setopt xtrace prompt_subst
     fi
   #+END_SRC
   
   And then add this at the end:
   #+NAME: stop-profiling
   #+BEGIN_SRC sh :results output :exports none :tangle no
     if [[ "$PROFILE_STARTUP" == true ]]; then
	 unsetopt xtrace
	 exec 2>&3 3>&-
     fi
   #+END_SRC
   
   The output file can be processed using [[ ][this script]].

*** Pass in meta-configurations
    #+BEGIN_SRC sh :noweb yes :tangle "~/.zshrc"
      # DO NOT EDIT
      # This file is generated by conf.org from xywei/conforg,
      # all changes will be overwritten.
      
      <<start-profiling>>

      export CONFORG_DIR=<<conforg-dir>>
      export CONDA_DIR=<<conda-dir>>
      export CLI_UTILS_DIR=<<cli-utils-dir>>
    #+END_SRC

*** Basic setup
    Do nothing if not running interactively
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      case $- in
	  ,*i*) ;;
	    ,*) return;;
      esac
    #+END_SRC
    
    Use emacs mode
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      bindkey -e
    #+END_SRC
    
    Fix GPG complaints
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      export GPG_TTY=$(tty)
    #+END_SRC

*** Bash insulter
    Just to add some fun..
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      if [ -f $CONFORG_DIR/contrib/bash-insulter/src/bash.command-not-found ]; then
	source $CONFORG_DIR/contrib/bash-insulter/src/bash.command-not-found
      fi
    #+END_SRC

*** Environment variables
    Set PATH to include:
    - cli-utils: my scripts
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      export PATH=$CLI_UTILS_DIR:$PATH
    #+END_SRC
    
    Set default editor to be neovim
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      export EDITOR="nvim"
      export VISUAL="nvim"
    #+END_SRC
    
    Enable 256 color support in terminal
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      export TERM=screen-256color
    #+END_SRC
    
    Allow using pip outside a virtual env
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      export PIP_REQUIRE_VIRTUALENV=false
    #+END_SRC

*** Command history
    Save 1000 commands and enable history sharing among all terminals
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      SAVEHIST=1000
      HISTFILE=~/.zsh_history
      setopt inc_append_history
    #+END_SRC
    
*** Auto completion
    Enable completion by putting =compinit= at the end of the zshrc
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      autoload -Uz compinit
    #+END_SRC

    Git command autocomplete
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      GIT_COMPLETION_BASH=/usr/share/git/completion/git-completion.zsh
      if [ -f $GIT_COMPLETION_ZSH ]; then
	zstyle ':completion:*:*:git:*' script $GIT_COMPLETION_ZSH
      fi
    #+END_SRC

    Taskwarrior. For Arch Linux, install `community/task`.
    This also sets the alias `t`.
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      zstyle ':completion:*:*:task:*' verbose yes
      zstyle ':completion:*:*:task:*:descriptions' format '%U%B%d%b%u'

      zstyle ':completion:*:*:task:*' group-name ''

      alias t=task
      compdef _task t=task
    #+END_SRC

*** Colorful aliases
    Enable color support of ls and also add handy aliases
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      alias ls='ls --color=auto'
      alias dir='dir --color=auto'
      alias vdir='vdir --color=auto'

      alias grep='grep --color=auto'
      alias fgrep='fgrep --color=auto'
      alias egrep='egrep --color=auto'
    #+END_SRC

*** Convenient aliases
    Some aliases for ls
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      alias ll='ls -alhF'
      alias la='ls -A'
      alias l='ls -CF'
    #+END_SRC
    
    Use =nvim= for everything
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      alias vi='nvim'
      alias vim='nvim'
    #+END_SRC
    
    Use Bash as the default shell for Emacs, due to compatibility issues for certain
    plugins.
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      alias emacs='SHELL=/bin/bash emacs'
    #+END_SRC
    
    A simple calculator.
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      autoload -U zcalc
      function __calc_plugin {
	  zcalc -e "$*"
      }
      aliases[calc]='noglob __calc_plugin'
      aliases[=]='noglob __calc_plugin'
    #+END_SRC

*** Dircolors
    Solarized dircolors. Choices are:
    - dircolors.256dark
    - dircolors.ansi-dark
    - dircolors.ansi-light
    - dircolors.ansi-universal
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      export DIRCOLORTHEME='dircolors.256dark'
      export DIRCOLOR_DIR=$CONFORG_DIR/contrib/dircolors-solarized
      eval `dircolors $DIRCOLOR_DIR/${DIRCOLORTHEME:-dircolors.256dark}`
      zstyle ':completion:*' list-colors "${(@s.:.)LS_COLORS}"
    #+END_SRC

*** End of zshrc
    Speed up zsh compinit by only checking cache once a day.
    On slow systems, checking the cached =.zcompdump= file to see if it must be 
    regenerated adds a noticable delay to zsh startup.
    This little hack restricts it to once a day.  
    Credit of this trick goes to [[https://gist.github.com/ctechols/ca1035271ad134841284][here]].

    The globbing is a little complicated here:
    - '#q' is an explicit glob qualifier that makes globbing work within zsh's [[ ]] construct.
    - 'N' makes the glob pattern evaluate to nothing when it doesn't match (rather than throw a globbing error)
    - '.' matches "regular files"
    - 'mh+24' matches files (or directories or whatever) that are older than 24 hours.

    #+BEGIN_SRC sh :tangle "~/.zshrc"
      for dump in $HOME/.zcompdump(N.mh+24); do
	  # echo "Updating completion cache.."
	  compinit
	  compdump
      done

      compinit -C
    #+END_SRC
    
    Stop profiling
    #+BEGIN_SRC sh :noweb yes :tangle "~/.zshrc"
      <<stop-profiling>>
    #+END_SRC
* Boneyard

This place is for configs that are gathered over time and are not ready
to land yet.
*** Conda
    Starting from conda 4.4 it uses `conda activate`, which is nice
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      . $CONDA_DIR/etc/profile.d/conda.sh
    #+END_SRC
    
    Conda commands autocompletion, making startup much slower
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      fpath+=$CONFORG_DIR/contrib/conda-zsh-completion
      compinit conda
      zstyle ':completion::complete:*' use-cache 1
    #+END_SRC

*** Prompt line
    When there is a custom promptline script, load it
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      if [ -f $CLI_UTILS_DIR/promptline ]; then
	source $CLI_UTILS_DIR/promptline
      fi
    #+END_SRC

*** Keyboard (Delete, Meta, PageUp etc.)
    Setup zkbd to use some keys in zsh. It prompts for an interactive setup when
    used for the first time. Note that the file generated sometimes does not
    have the correct filename.
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      autoload zkbd
      [[ ! -f ${ZDOTDIR:-$HOME}/.zkbd/$TERM-$VENDOR-$OSTYPE ]] && zkbd
      source ${ZDOTDIR:-$HOME}/.zkbd/$TERM-$VENDOR-$OSTYPE

      [[ -n ${key[Backspace]} ]] && bindkey "${key[Backspace]}" backward-delete-char
      [[ -n ${key[Insert]} ]] && bindkey "${key[Insert]}" overwrite-mode
      [[ -n ${key[Home]} ]] && bindkey "${key[Home]}" beginning-of-line
      [[ -n ${key[PageUp]} ]] && bindkey "${key[PageUp]}" up-line-or-history
      [[ -n ${key[Delete]} ]] && bindkey "${key[Delete]}" delete-char
      [[ -n ${key[End]} ]] && bindkey "${key[End]}" end-of-line
      [[ -n ${key[PageDown]} ]] && bindkey "${key[PageDown]}" down-line-or-history
      [[ -n ${key[Up]} ]] && bindkey "${key[Up]}" up-line-or-search
      [[ -n ${key[Left]} ]] && bindkey "${key[Left]}" backward-char
      [[ -n ${key[Down]} ]] && bindkey "${key[Down]}" down-line-or-search
      [[ -n ${key[Right]} ]] && bindkey "${key[Right]}" forward-char
    #+END_SRC

*** Theme: PowerLevel9k
    Theme settings
    #+BEGIN_SRC sh :tangle "~/.zshrc"
      POWERLEVEL9K_COLOR_SCHEME='light'
      POWERLEVEL9K_MODE='nerdfont-complete'
      POWERLEVEL9K_PROMPT_ON_NEWLINE=true
      POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(os_icon context dir)
      POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status root_indicator background_jobs history time)
      source  $CONFORG_DIR/contrib/powerlevel9k/powerlevel9k.zsh-theme
    #+END_SRC

*** Taskwarrior
